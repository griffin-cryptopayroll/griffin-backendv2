// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"griffin-dao/ent/crypto_currency"
	"griffin-dao/ent/crypto_prc_source"
	"griffin-dao/ent/employ_type"
	"griffin-dao/ent/employee"
	"griffin-dao/ent/employer"
	"griffin-dao/ent/payment_history"
	"griffin-dao/ent/predicate"
	"griffin-dao/ent/tr_log"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCRYPTO_CURRENCY   = "CRYPTO_CURRENCY"
	TypeCRYPTO_PRC_SOURCE = "CRYPTO_PRC_SOURCE"
	TypeEMPLOYEE          = "EMPLOYEE"
	TypeEMPLOYER          = "EMPLOYER"
	TypeEMPLOY_TYPE       = "EMPLOY_TYPE"
	TypePAYMENT_HISTORY   = "PAYMENT_HISTORY"
	TypeTr_log            = "Tr_log"
)

// CRYPTOCURRENCYMutation represents an operation that mutates the CRYPTO_CURRENCY nodes in the graph.
type CRYPTOCURRENCYMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	ticker                      *string
	clearedFields               map[string]struct{}
	currency_from_source        *int
	clearedcurrency_from_source bool
	currency_of_employee        map[int]struct{}
	removedcurrency_of_employee map[int]struct{}
	clearedcurrency_of_employee bool
	done                        bool
	oldValue                    func(context.Context) (*CRYPTO_CURRENCY, error)
	predicates                  []predicate.CRYPTO_CURRENCY
}

var _ ent.Mutation = (*CRYPTOCURRENCYMutation)(nil)

// cryptoCURRENCYOption allows management of the mutation configuration using functional options.
type cryptoCURRENCYOption func(*CRYPTOCURRENCYMutation)

// newCRYPTOCURRENCYMutation creates new mutation for the CRYPTO_CURRENCY entity.
func newCRYPTOCURRENCYMutation(c config, op Op, opts ...cryptoCURRENCYOption) *CRYPTOCURRENCYMutation {
	m := &CRYPTOCURRENCYMutation{
		config:        c,
		op:            op,
		typ:           TypeCRYPTO_CURRENCY,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCRYPTO_CURRENCYID sets the ID field of the mutation.
func withCRYPTO_CURRENCYID(id int) cryptoCURRENCYOption {
	return func(m *CRYPTOCURRENCYMutation) {
		var (
			err   error
			once  sync.Once
			value *CRYPTO_CURRENCY
		)
		m.oldValue = func(ctx context.Context) (*CRYPTO_CURRENCY, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CRYPTO_CURRENCY.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCRYPTO_CURRENCY sets the old CRYPTO_CURRENCY of the mutation.
func withCRYPTO_CURRENCY(node *CRYPTO_CURRENCY) cryptoCURRENCYOption {
	return func(m *CRYPTOCURRENCYMutation) {
		m.oldValue = func(context.Context) (*CRYPTO_CURRENCY, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CRYPTOCURRENCYMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CRYPTOCURRENCYMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CRYPTO_CURRENCY entities.
func (m *CRYPTOCURRENCYMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CRYPTOCURRENCYMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CRYPTOCURRENCYMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CRYPTO_CURRENCY.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTicker sets the "ticker" field.
func (m *CRYPTOCURRENCYMutation) SetTicker(s string) {
	m.ticker = &s
}

// Ticker returns the value of the "ticker" field in the mutation.
func (m *CRYPTOCURRENCYMutation) Ticker() (r string, exists bool) {
	v := m.ticker
	if v == nil {
		return
	}
	return *v, true
}

// OldTicker returns the old "ticker" field's value of the CRYPTO_CURRENCY entity.
// If the CRYPTO_CURRENCY object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CRYPTOCURRENCYMutation) OldTicker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicker: %w", err)
	}
	return oldValue.Ticker, nil
}

// ResetTicker resets all changes to the "ticker" field.
func (m *CRYPTOCURRENCYMutation) ResetTicker() {
	m.ticker = nil
}

// SetSourceID sets the "source_id" field.
func (m *CRYPTOCURRENCYMutation) SetSourceID(i int) {
	m.currency_from_source = &i
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *CRYPTOCURRENCYMutation) SourceID() (r int, exists bool) {
	v := m.currency_from_source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the CRYPTO_CURRENCY entity.
// If the CRYPTO_CURRENCY object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CRYPTOCURRENCYMutation) OldSourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ClearSourceID clears the value of the "source_id" field.
func (m *CRYPTOCURRENCYMutation) ClearSourceID() {
	m.currency_from_source = nil
	m.clearedFields[crypto_currency.FieldSourceID] = struct{}{}
}

// SourceIDCleared returns if the "source_id" field was cleared in this mutation.
func (m *CRYPTOCURRENCYMutation) SourceIDCleared() bool {
	_, ok := m.clearedFields[crypto_currency.FieldSourceID]
	return ok
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *CRYPTOCURRENCYMutation) ResetSourceID() {
	m.currency_from_source = nil
	delete(m.clearedFields, crypto_currency.FieldSourceID)
}

// SetCurrencyFromSourceID sets the "currency_from_source" edge to the CRYPTO_PRC_SOURCE entity by id.
func (m *CRYPTOCURRENCYMutation) SetCurrencyFromSourceID(id int) {
	m.currency_from_source = &id
}

// ClearCurrencyFromSource clears the "currency_from_source" edge to the CRYPTO_PRC_SOURCE entity.
func (m *CRYPTOCURRENCYMutation) ClearCurrencyFromSource() {
	m.clearedcurrency_from_source = true
}

// CurrencyFromSourceCleared reports if the "currency_from_source" edge to the CRYPTO_PRC_SOURCE entity was cleared.
func (m *CRYPTOCURRENCYMutation) CurrencyFromSourceCleared() bool {
	return m.SourceIDCleared() || m.clearedcurrency_from_source
}

// CurrencyFromSourceID returns the "currency_from_source" edge ID in the mutation.
func (m *CRYPTOCURRENCYMutation) CurrencyFromSourceID() (id int, exists bool) {
	if m.currency_from_source != nil {
		return *m.currency_from_source, true
	}
	return
}

// CurrencyFromSourceIDs returns the "currency_from_source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrencyFromSourceID instead. It exists only for internal usage by the builders.
func (m *CRYPTOCURRENCYMutation) CurrencyFromSourceIDs() (ids []int) {
	if id := m.currency_from_source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrencyFromSource resets all changes to the "currency_from_source" edge.
func (m *CRYPTOCURRENCYMutation) ResetCurrencyFromSource() {
	m.currency_from_source = nil
	m.clearedcurrency_from_source = false
}

// AddCurrencyOfEmployeeIDs adds the "currency_of_employee" edge to the EMPLOYEE entity by ids.
func (m *CRYPTOCURRENCYMutation) AddCurrencyOfEmployeeIDs(ids ...int) {
	if m.currency_of_employee == nil {
		m.currency_of_employee = make(map[int]struct{})
	}
	for i := range ids {
		m.currency_of_employee[ids[i]] = struct{}{}
	}
}

// ClearCurrencyOfEmployee clears the "currency_of_employee" edge to the EMPLOYEE entity.
func (m *CRYPTOCURRENCYMutation) ClearCurrencyOfEmployee() {
	m.clearedcurrency_of_employee = true
}

// CurrencyOfEmployeeCleared reports if the "currency_of_employee" edge to the EMPLOYEE entity was cleared.
func (m *CRYPTOCURRENCYMutation) CurrencyOfEmployeeCleared() bool {
	return m.clearedcurrency_of_employee
}

// RemoveCurrencyOfEmployeeIDs removes the "currency_of_employee" edge to the EMPLOYEE entity by IDs.
func (m *CRYPTOCURRENCYMutation) RemoveCurrencyOfEmployeeIDs(ids ...int) {
	if m.removedcurrency_of_employee == nil {
		m.removedcurrency_of_employee = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.currency_of_employee, ids[i])
		m.removedcurrency_of_employee[ids[i]] = struct{}{}
	}
}

// RemovedCurrencyOfEmployee returns the removed IDs of the "currency_of_employee" edge to the EMPLOYEE entity.
func (m *CRYPTOCURRENCYMutation) RemovedCurrencyOfEmployeeIDs() (ids []int) {
	for id := range m.removedcurrency_of_employee {
		ids = append(ids, id)
	}
	return
}

// CurrencyOfEmployeeIDs returns the "currency_of_employee" edge IDs in the mutation.
func (m *CRYPTOCURRENCYMutation) CurrencyOfEmployeeIDs() (ids []int) {
	for id := range m.currency_of_employee {
		ids = append(ids, id)
	}
	return
}

// ResetCurrencyOfEmployee resets all changes to the "currency_of_employee" edge.
func (m *CRYPTOCURRENCYMutation) ResetCurrencyOfEmployee() {
	m.currency_of_employee = nil
	m.clearedcurrency_of_employee = false
	m.removedcurrency_of_employee = nil
}

// Where appends a list predicates to the CRYPTOCURRENCYMutation builder.
func (m *CRYPTOCURRENCYMutation) Where(ps ...predicate.CRYPTO_CURRENCY) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CRYPTOCURRENCYMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CRYPTO_CURRENCY).
func (m *CRYPTOCURRENCYMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CRYPTOCURRENCYMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.ticker != nil {
		fields = append(fields, crypto_currency.FieldTicker)
	}
	if m.currency_from_source != nil {
		fields = append(fields, crypto_currency.FieldSourceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CRYPTOCURRENCYMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case crypto_currency.FieldTicker:
		return m.Ticker()
	case crypto_currency.FieldSourceID:
		return m.SourceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CRYPTOCURRENCYMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case crypto_currency.FieldTicker:
		return m.OldTicker(ctx)
	case crypto_currency.FieldSourceID:
		return m.OldSourceID(ctx)
	}
	return nil, fmt.Errorf("unknown CRYPTO_CURRENCY field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CRYPTOCURRENCYMutation) SetField(name string, value ent.Value) error {
	switch name {
	case crypto_currency.FieldTicker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicker(v)
		return nil
	case crypto_currency.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	}
	return fmt.Errorf("unknown CRYPTO_CURRENCY field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CRYPTOCURRENCYMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CRYPTOCURRENCYMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CRYPTOCURRENCYMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CRYPTO_CURRENCY numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CRYPTOCURRENCYMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(crypto_currency.FieldSourceID) {
		fields = append(fields, crypto_currency.FieldSourceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CRYPTOCURRENCYMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CRYPTOCURRENCYMutation) ClearField(name string) error {
	switch name {
	case crypto_currency.FieldSourceID:
		m.ClearSourceID()
		return nil
	}
	return fmt.Errorf("unknown CRYPTO_CURRENCY nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CRYPTOCURRENCYMutation) ResetField(name string) error {
	switch name {
	case crypto_currency.FieldTicker:
		m.ResetTicker()
		return nil
	case crypto_currency.FieldSourceID:
		m.ResetSourceID()
		return nil
	}
	return fmt.Errorf("unknown CRYPTO_CURRENCY field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CRYPTOCURRENCYMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.currency_from_source != nil {
		edges = append(edges, crypto_currency.EdgeCurrencyFromSource)
	}
	if m.currency_of_employee != nil {
		edges = append(edges, crypto_currency.EdgeCurrencyOfEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CRYPTOCURRENCYMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case crypto_currency.EdgeCurrencyFromSource:
		if id := m.currency_from_source; id != nil {
			return []ent.Value{*id}
		}
	case crypto_currency.EdgeCurrencyOfEmployee:
		ids := make([]ent.Value, 0, len(m.currency_of_employee))
		for id := range m.currency_of_employee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CRYPTOCURRENCYMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcurrency_of_employee != nil {
		edges = append(edges, crypto_currency.EdgeCurrencyOfEmployee)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CRYPTOCURRENCYMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case crypto_currency.EdgeCurrencyOfEmployee:
		ids := make([]ent.Value, 0, len(m.removedcurrency_of_employee))
		for id := range m.removedcurrency_of_employee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CRYPTOCURRENCYMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcurrency_from_source {
		edges = append(edges, crypto_currency.EdgeCurrencyFromSource)
	}
	if m.clearedcurrency_of_employee {
		edges = append(edges, crypto_currency.EdgeCurrencyOfEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CRYPTOCURRENCYMutation) EdgeCleared(name string) bool {
	switch name {
	case crypto_currency.EdgeCurrencyFromSource:
		return m.clearedcurrency_from_source
	case crypto_currency.EdgeCurrencyOfEmployee:
		return m.clearedcurrency_of_employee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CRYPTOCURRENCYMutation) ClearEdge(name string) error {
	switch name {
	case crypto_currency.EdgeCurrencyFromSource:
		m.ClearCurrencyFromSource()
		return nil
	}
	return fmt.Errorf("unknown CRYPTO_CURRENCY unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CRYPTOCURRENCYMutation) ResetEdge(name string) error {
	switch name {
	case crypto_currency.EdgeCurrencyFromSource:
		m.ResetCurrencyFromSource()
		return nil
	case crypto_currency.EdgeCurrencyOfEmployee:
		m.ResetCurrencyOfEmployee()
		return nil
	}
	return fmt.Errorf("unknown CRYPTO_CURRENCY edge %s", name)
}

// CRYPTOPRCSOURCEMutation represents an operation that mutates the CRYPTO_PRC_SOURCE nodes in the graph.
type CRYPTOPRCSOURCEMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	clearedFields             map[string]struct{}
	source_of_currency        map[int]struct{}
	removedsource_of_currency map[int]struct{}
	clearedsource_of_currency bool
	done                      bool
	oldValue                  func(context.Context) (*CRYPTO_PRC_SOURCE, error)
	predicates                []predicate.CRYPTO_PRC_SOURCE
}

var _ ent.Mutation = (*CRYPTOPRCSOURCEMutation)(nil)

// cryptoPRCSOURCEOption allows management of the mutation configuration using functional options.
type cryptoPRCSOURCEOption func(*CRYPTOPRCSOURCEMutation)

// newCRYPTOPRCSOURCEMutation creates new mutation for the CRYPTO_PRC_SOURCE entity.
func newCRYPTOPRCSOURCEMutation(c config, op Op, opts ...cryptoPRCSOURCEOption) *CRYPTOPRCSOURCEMutation {
	m := &CRYPTOPRCSOURCEMutation{
		config:        c,
		op:            op,
		typ:           TypeCRYPTO_PRC_SOURCE,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCRYPTO_PRC_SOURCEID sets the ID field of the mutation.
func withCRYPTO_PRC_SOURCEID(id int) cryptoPRCSOURCEOption {
	return func(m *CRYPTOPRCSOURCEMutation) {
		var (
			err   error
			once  sync.Once
			value *CRYPTO_PRC_SOURCE
		)
		m.oldValue = func(ctx context.Context) (*CRYPTO_PRC_SOURCE, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CRYPTO_PRC_SOURCE.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCRYPTO_PRC_SOURCE sets the old CRYPTO_PRC_SOURCE of the mutation.
func withCRYPTO_PRC_SOURCE(node *CRYPTO_PRC_SOURCE) cryptoPRCSOURCEOption {
	return func(m *CRYPTOPRCSOURCEMutation) {
		m.oldValue = func(context.Context) (*CRYPTO_PRC_SOURCE, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CRYPTOPRCSOURCEMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CRYPTOPRCSOURCEMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CRYPTO_PRC_SOURCE entities.
func (m *CRYPTOPRCSOURCEMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CRYPTOPRCSOURCEMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CRYPTOPRCSOURCEMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CRYPTO_PRC_SOURCE.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CRYPTOPRCSOURCEMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CRYPTOPRCSOURCEMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CRYPTO_PRC_SOURCE entity.
// If the CRYPTO_PRC_SOURCE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CRYPTOPRCSOURCEMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CRYPTOPRCSOURCEMutation) ResetName() {
	m.name = nil
}

// AddSourceOfCurrencyIDs adds the "source_of_currency" edge to the CRYPTO_CURRENCY entity by ids.
func (m *CRYPTOPRCSOURCEMutation) AddSourceOfCurrencyIDs(ids ...int) {
	if m.source_of_currency == nil {
		m.source_of_currency = make(map[int]struct{})
	}
	for i := range ids {
		m.source_of_currency[ids[i]] = struct{}{}
	}
}

// ClearSourceOfCurrency clears the "source_of_currency" edge to the CRYPTO_CURRENCY entity.
func (m *CRYPTOPRCSOURCEMutation) ClearSourceOfCurrency() {
	m.clearedsource_of_currency = true
}

// SourceOfCurrencyCleared reports if the "source_of_currency" edge to the CRYPTO_CURRENCY entity was cleared.
func (m *CRYPTOPRCSOURCEMutation) SourceOfCurrencyCleared() bool {
	return m.clearedsource_of_currency
}

// RemoveSourceOfCurrencyIDs removes the "source_of_currency" edge to the CRYPTO_CURRENCY entity by IDs.
func (m *CRYPTOPRCSOURCEMutation) RemoveSourceOfCurrencyIDs(ids ...int) {
	if m.removedsource_of_currency == nil {
		m.removedsource_of_currency = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.source_of_currency, ids[i])
		m.removedsource_of_currency[ids[i]] = struct{}{}
	}
}

// RemovedSourceOfCurrency returns the removed IDs of the "source_of_currency" edge to the CRYPTO_CURRENCY entity.
func (m *CRYPTOPRCSOURCEMutation) RemovedSourceOfCurrencyIDs() (ids []int) {
	for id := range m.removedsource_of_currency {
		ids = append(ids, id)
	}
	return
}

// SourceOfCurrencyIDs returns the "source_of_currency" edge IDs in the mutation.
func (m *CRYPTOPRCSOURCEMutation) SourceOfCurrencyIDs() (ids []int) {
	for id := range m.source_of_currency {
		ids = append(ids, id)
	}
	return
}

// ResetSourceOfCurrency resets all changes to the "source_of_currency" edge.
func (m *CRYPTOPRCSOURCEMutation) ResetSourceOfCurrency() {
	m.source_of_currency = nil
	m.clearedsource_of_currency = false
	m.removedsource_of_currency = nil
}

// Where appends a list predicates to the CRYPTOPRCSOURCEMutation builder.
func (m *CRYPTOPRCSOURCEMutation) Where(ps ...predicate.CRYPTO_PRC_SOURCE) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CRYPTOPRCSOURCEMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CRYPTO_PRC_SOURCE).
func (m *CRYPTOPRCSOURCEMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CRYPTOPRCSOURCEMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, crypto_prc_source.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CRYPTOPRCSOURCEMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case crypto_prc_source.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CRYPTOPRCSOURCEMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case crypto_prc_source.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CRYPTO_PRC_SOURCE field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CRYPTOPRCSOURCEMutation) SetField(name string, value ent.Value) error {
	switch name {
	case crypto_prc_source.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CRYPTO_PRC_SOURCE field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CRYPTOPRCSOURCEMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CRYPTOPRCSOURCEMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CRYPTOPRCSOURCEMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CRYPTO_PRC_SOURCE numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CRYPTOPRCSOURCEMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CRYPTOPRCSOURCEMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CRYPTOPRCSOURCEMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CRYPTO_PRC_SOURCE nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CRYPTOPRCSOURCEMutation) ResetField(name string) error {
	switch name {
	case crypto_prc_source.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CRYPTO_PRC_SOURCE field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CRYPTOPRCSOURCEMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.source_of_currency != nil {
		edges = append(edges, crypto_prc_source.EdgeSourceOfCurrency)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CRYPTOPRCSOURCEMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case crypto_prc_source.EdgeSourceOfCurrency:
		ids := make([]ent.Value, 0, len(m.source_of_currency))
		for id := range m.source_of_currency {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CRYPTOPRCSOURCEMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsource_of_currency != nil {
		edges = append(edges, crypto_prc_source.EdgeSourceOfCurrency)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CRYPTOPRCSOURCEMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case crypto_prc_source.EdgeSourceOfCurrency:
		ids := make([]ent.Value, 0, len(m.removedsource_of_currency))
		for id := range m.removedsource_of_currency {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CRYPTOPRCSOURCEMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsource_of_currency {
		edges = append(edges, crypto_prc_source.EdgeSourceOfCurrency)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CRYPTOPRCSOURCEMutation) EdgeCleared(name string) bool {
	switch name {
	case crypto_prc_source.EdgeSourceOfCurrency:
		return m.clearedsource_of_currency
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CRYPTOPRCSOURCEMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CRYPTO_PRC_SOURCE unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CRYPTOPRCSOURCEMutation) ResetEdge(name string) error {
	switch name {
	case crypto_prc_source.EdgeSourceOfCurrency:
		m.ResetSourceOfCurrency()
		return nil
	}
	return fmt.Errorf("unknown CRYPTO_PRC_SOURCE edge %s", name)
}

// EMPLOYEEMutation represents an operation that mutates the EMPLOYEE nodes in the graph.
type EMPLOYEEMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	gid                                *string
	name                               *string
	position                           *string
	wallet                             *string
	payroll                            *float64
	addpayroll                         *float64
	payday                             *time.Time
	email                              *string
	work_start                         *string
	work_ends                          *string
	created_at                         *time.Time
	created_by                         *string
	updated_at                         *time.Time
	updated_by                         *string
	clearedFields                      map[string]struct{}
	employee_from_currency             *int
	clearedemployee_from_currency      bool
	employee_from_employ_type          *int
	clearedemployee_from_employ_type   bool
	employee_from_employer             *int
	clearedemployee_from_employer      bool
	employee_of_payment_history        map[int]struct{}
	removedemployee_of_payment_history map[int]struct{}
	clearedemployee_of_payment_history bool
	done                               bool
	oldValue                           func(context.Context) (*EMPLOYEE, error)
	predicates                         []predicate.EMPLOYEE
}

var _ ent.Mutation = (*EMPLOYEEMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EMPLOYEEMutation)

// newEMPLOYEEMutation creates new mutation for the EMPLOYEE entity.
func newEMPLOYEEMutation(c config, op Op, opts ...employeeOption) *EMPLOYEEMutation {
	m := &EMPLOYEEMutation{
		config:        c,
		op:            op,
		typ:           TypeEMPLOYEE,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEMPLOYEEID sets the ID field of the mutation.
func withEMPLOYEEID(id int) employeeOption {
	return func(m *EMPLOYEEMutation) {
		var (
			err   error
			once  sync.Once
			value *EMPLOYEE
		)
		m.oldValue = func(ctx context.Context) (*EMPLOYEE, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EMPLOYEE.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEMPLOYEE sets the old EMPLOYEE of the mutation.
func withEMPLOYEE(node *EMPLOYEE) employeeOption {
	return func(m *EMPLOYEEMutation) {
		m.oldValue = func(context.Context) (*EMPLOYEE, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EMPLOYEEMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EMPLOYEEMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EMPLOYEE entities.
func (m *EMPLOYEEMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EMPLOYEEMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EMPLOYEEMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EMPLOYEE.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGid sets the "gid" field.
func (m *EMPLOYEEMutation) SetGid(s string) {
	m.gid = &s
}

// Gid returns the value of the "gid" field in the mutation.
func (m *EMPLOYEEMutation) Gid() (r string, exists bool) {
	v := m.gid
	if v == nil {
		return
	}
	return *v, true
}

// OldGid returns the old "gid" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldGid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGid: %w", err)
	}
	return oldValue.Gid, nil
}

// ResetGid resets all changes to the "gid" field.
func (m *EMPLOYEEMutation) ResetGid() {
	m.gid = nil
}

// SetEmployerID sets the "employer_id" field.
func (m *EMPLOYEEMutation) SetEmployerID(i int) {
	m.employee_from_employer = &i
}

// EmployerID returns the value of the "employer_id" field in the mutation.
func (m *EMPLOYEEMutation) EmployerID() (r int, exists bool) {
	v := m.employee_from_employer
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployerID returns the old "employer_id" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldEmployerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployerID: %w", err)
	}
	return oldValue.EmployerID, nil
}

// ClearEmployerID clears the value of the "employer_id" field.
func (m *EMPLOYEEMutation) ClearEmployerID() {
	m.employee_from_employer = nil
	m.clearedFields[employee.FieldEmployerID] = struct{}{}
}

// EmployerIDCleared returns if the "employer_id" field was cleared in this mutation.
func (m *EMPLOYEEMutation) EmployerIDCleared() bool {
	_, ok := m.clearedFields[employee.FieldEmployerID]
	return ok
}

// ResetEmployerID resets all changes to the "employer_id" field.
func (m *EMPLOYEEMutation) ResetEmployerID() {
	m.employee_from_employer = nil
	delete(m.clearedFields, employee.FieldEmployerID)
}

// SetName sets the "name" field.
func (m *EMPLOYEEMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EMPLOYEEMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EMPLOYEEMutation) ResetName() {
	m.name = nil
}

// SetPosition sets the "position" field.
func (m *EMPLOYEEMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *EMPLOYEEMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition resets all changes to the "position" field.
func (m *EMPLOYEEMutation) ResetPosition() {
	m.position = nil
}

// SetWallet sets the "wallet" field.
func (m *EMPLOYEEMutation) SetWallet(s string) {
	m.wallet = &s
}

// Wallet returns the value of the "wallet" field in the mutation.
func (m *EMPLOYEEMutation) Wallet() (r string, exists bool) {
	v := m.wallet
	if v == nil {
		return
	}
	return *v, true
}

// OldWallet returns the old "wallet" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldWallet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWallet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWallet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWallet: %w", err)
	}
	return oldValue.Wallet, nil
}

// ResetWallet resets all changes to the "wallet" field.
func (m *EMPLOYEEMutation) ResetWallet() {
	m.wallet = nil
}

// SetPayroll sets the "payroll" field.
func (m *EMPLOYEEMutation) SetPayroll(f float64) {
	m.payroll = &f
	m.addpayroll = nil
}

// Payroll returns the value of the "payroll" field in the mutation.
func (m *EMPLOYEEMutation) Payroll() (r float64, exists bool) {
	v := m.payroll
	if v == nil {
		return
	}
	return *v, true
}

// OldPayroll returns the old "payroll" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldPayroll(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayroll is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayroll requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayroll: %w", err)
	}
	return oldValue.Payroll, nil
}

// AddPayroll adds f to the "payroll" field.
func (m *EMPLOYEEMutation) AddPayroll(f float64) {
	if m.addpayroll != nil {
		*m.addpayroll += f
	} else {
		m.addpayroll = &f
	}
}

// AddedPayroll returns the value that was added to the "payroll" field in this mutation.
func (m *EMPLOYEEMutation) AddedPayroll() (r float64, exists bool) {
	v := m.addpayroll
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayroll resets all changes to the "payroll" field.
func (m *EMPLOYEEMutation) ResetPayroll() {
	m.payroll = nil
	m.addpayroll = nil
}

// SetCryptoCurrencyID sets the "crypto_currency_id" field.
func (m *EMPLOYEEMutation) SetCryptoCurrencyID(i int) {
	m.employee_from_currency = &i
}

// CryptoCurrencyID returns the value of the "crypto_currency_id" field in the mutation.
func (m *EMPLOYEEMutation) CryptoCurrencyID() (r int, exists bool) {
	v := m.employee_from_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCryptoCurrencyID returns the old "crypto_currency_id" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldCryptoCurrencyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCryptoCurrencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCryptoCurrencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCryptoCurrencyID: %w", err)
	}
	return oldValue.CryptoCurrencyID, nil
}

// ClearCryptoCurrencyID clears the value of the "crypto_currency_id" field.
func (m *EMPLOYEEMutation) ClearCryptoCurrencyID() {
	m.employee_from_currency = nil
	m.clearedFields[employee.FieldCryptoCurrencyID] = struct{}{}
}

// CryptoCurrencyIDCleared returns if the "crypto_currency_id" field was cleared in this mutation.
func (m *EMPLOYEEMutation) CryptoCurrencyIDCleared() bool {
	_, ok := m.clearedFields[employee.FieldCryptoCurrencyID]
	return ok
}

// ResetCryptoCurrencyID resets all changes to the "crypto_currency_id" field.
func (m *EMPLOYEEMutation) ResetCryptoCurrencyID() {
	m.employee_from_currency = nil
	delete(m.clearedFields, employee.FieldCryptoCurrencyID)
}

// SetPayday sets the "payday" field.
func (m *EMPLOYEEMutation) SetPayday(t time.Time) {
	m.payday = &t
}

// Payday returns the value of the "payday" field in the mutation.
func (m *EMPLOYEEMutation) Payday() (r time.Time, exists bool) {
	v := m.payday
	if v == nil {
		return
	}
	return *v, true
}

// OldPayday returns the old "payday" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldPayday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayday: %w", err)
	}
	return oldValue.Payday, nil
}

// ResetPayday resets all changes to the "payday" field.
func (m *EMPLOYEEMutation) ResetPayday() {
	m.payday = nil
}

// SetEmployTypeID sets the "employ_type_id" field.
func (m *EMPLOYEEMutation) SetEmployTypeID(i int) {
	m.employee_from_employ_type = &i
}

// EmployTypeID returns the value of the "employ_type_id" field in the mutation.
func (m *EMPLOYEEMutation) EmployTypeID() (r int, exists bool) {
	v := m.employee_from_employ_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployTypeID returns the old "employ_type_id" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldEmployTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployTypeID: %w", err)
	}
	return oldValue.EmployTypeID, nil
}

// ClearEmployTypeID clears the value of the "employ_type_id" field.
func (m *EMPLOYEEMutation) ClearEmployTypeID() {
	m.employee_from_employ_type = nil
	m.clearedFields[employee.FieldEmployTypeID] = struct{}{}
}

// EmployTypeIDCleared returns if the "employ_type_id" field was cleared in this mutation.
func (m *EMPLOYEEMutation) EmployTypeIDCleared() bool {
	_, ok := m.clearedFields[employee.FieldEmployTypeID]
	return ok
}

// ResetEmployTypeID resets all changes to the "employ_type_id" field.
func (m *EMPLOYEEMutation) ResetEmployTypeID() {
	m.employee_from_employ_type = nil
	delete(m.clearedFields, employee.FieldEmployTypeID)
}

// SetEmail sets the "email" field.
func (m *EMPLOYEEMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EMPLOYEEMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *EMPLOYEEMutation) ResetEmail() {
	m.email = nil
}

// SetWorkStart sets the "work_start" field.
func (m *EMPLOYEEMutation) SetWorkStart(s string) {
	m.work_start = &s
}

// WorkStart returns the value of the "work_start" field in the mutation.
func (m *EMPLOYEEMutation) WorkStart() (r string, exists bool) {
	v := m.work_start
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkStart returns the old "work_start" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldWorkStart(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkStart: %w", err)
	}
	return oldValue.WorkStart, nil
}

// ResetWorkStart resets all changes to the "work_start" field.
func (m *EMPLOYEEMutation) ResetWorkStart() {
	m.work_start = nil
}

// SetWorkEnds sets the "work_ends" field.
func (m *EMPLOYEEMutation) SetWorkEnds(s string) {
	m.work_ends = &s
}

// WorkEnds returns the value of the "work_ends" field in the mutation.
func (m *EMPLOYEEMutation) WorkEnds() (r string, exists bool) {
	v := m.work_ends
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkEnds returns the old "work_ends" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldWorkEnds(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkEnds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkEnds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkEnds: %w", err)
	}
	return oldValue.WorkEnds, nil
}

// ResetWorkEnds resets all changes to the "work_ends" field.
func (m *EMPLOYEEMutation) ResetWorkEnds() {
	m.work_ends = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EMPLOYEEMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EMPLOYEEMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EMPLOYEEMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EMPLOYEEMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EMPLOYEEMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EMPLOYEEMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EMPLOYEEMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EMPLOYEEMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EMPLOYEEMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EMPLOYEEMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EMPLOYEEMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EMPLOYEE entity.
// If the EMPLOYEE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYEEMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EMPLOYEEMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetEmployeeFromCurrencyID sets the "employee_from_currency" edge to the CRYPTO_CURRENCY entity by id.
func (m *EMPLOYEEMutation) SetEmployeeFromCurrencyID(id int) {
	m.employee_from_currency = &id
}

// ClearEmployeeFromCurrency clears the "employee_from_currency" edge to the CRYPTO_CURRENCY entity.
func (m *EMPLOYEEMutation) ClearEmployeeFromCurrency() {
	m.clearedemployee_from_currency = true
}

// EmployeeFromCurrencyCleared reports if the "employee_from_currency" edge to the CRYPTO_CURRENCY entity was cleared.
func (m *EMPLOYEEMutation) EmployeeFromCurrencyCleared() bool {
	return m.CryptoCurrencyIDCleared() || m.clearedemployee_from_currency
}

// EmployeeFromCurrencyID returns the "employee_from_currency" edge ID in the mutation.
func (m *EMPLOYEEMutation) EmployeeFromCurrencyID() (id int, exists bool) {
	if m.employee_from_currency != nil {
		return *m.employee_from_currency, true
	}
	return
}

// EmployeeFromCurrencyIDs returns the "employee_from_currency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeFromCurrencyID instead. It exists only for internal usage by the builders.
func (m *EMPLOYEEMutation) EmployeeFromCurrencyIDs() (ids []int) {
	if id := m.employee_from_currency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployeeFromCurrency resets all changes to the "employee_from_currency" edge.
func (m *EMPLOYEEMutation) ResetEmployeeFromCurrency() {
	m.employee_from_currency = nil
	m.clearedemployee_from_currency = false
}

// SetEmployeeFromEmployTypeID sets the "employee_from_employ_type" edge to the EMPLOY_TYPE entity by id.
func (m *EMPLOYEEMutation) SetEmployeeFromEmployTypeID(id int) {
	m.employee_from_employ_type = &id
}

// ClearEmployeeFromEmployType clears the "employee_from_employ_type" edge to the EMPLOY_TYPE entity.
func (m *EMPLOYEEMutation) ClearEmployeeFromEmployType() {
	m.clearedemployee_from_employ_type = true
}

// EmployeeFromEmployTypeCleared reports if the "employee_from_employ_type" edge to the EMPLOY_TYPE entity was cleared.
func (m *EMPLOYEEMutation) EmployeeFromEmployTypeCleared() bool {
	return m.EmployTypeIDCleared() || m.clearedemployee_from_employ_type
}

// EmployeeFromEmployTypeID returns the "employee_from_employ_type" edge ID in the mutation.
func (m *EMPLOYEEMutation) EmployeeFromEmployTypeID() (id int, exists bool) {
	if m.employee_from_employ_type != nil {
		return *m.employee_from_employ_type, true
	}
	return
}

// EmployeeFromEmployTypeIDs returns the "employee_from_employ_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeFromEmployTypeID instead. It exists only for internal usage by the builders.
func (m *EMPLOYEEMutation) EmployeeFromEmployTypeIDs() (ids []int) {
	if id := m.employee_from_employ_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployeeFromEmployType resets all changes to the "employee_from_employ_type" edge.
func (m *EMPLOYEEMutation) ResetEmployeeFromEmployType() {
	m.employee_from_employ_type = nil
	m.clearedemployee_from_employ_type = false
}

// SetEmployeeFromEmployerID sets the "employee_from_employer" edge to the EMPLOYER entity by id.
func (m *EMPLOYEEMutation) SetEmployeeFromEmployerID(id int) {
	m.employee_from_employer = &id
}

// ClearEmployeeFromEmployer clears the "employee_from_employer" edge to the EMPLOYER entity.
func (m *EMPLOYEEMutation) ClearEmployeeFromEmployer() {
	m.clearedemployee_from_employer = true
}

// EmployeeFromEmployerCleared reports if the "employee_from_employer" edge to the EMPLOYER entity was cleared.
func (m *EMPLOYEEMutation) EmployeeFromEmployerCleared() bool {
	return m.EmployerIDCleared() || m.clearedemployee_from_employer
}

// EmployeeFromEmployerID returns the "employee_from_employer" edge ID in the mutation.
func (m *EMPLOYEEMutation) EmployeeFromEmployerID() (id int, exists bool) {
	if m.employee_from_employer != nil {
		return *m.employee_from_employer, true
	}
	return
}

// EmployeeFromEmployerIDs returns the "employee_from_employer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeFromEmployerID instead. It exists only for internal usage by the builders.
func (m *EMPLOYEEMutation) EmployeeFromEmployerIDs() (ids []int) {
	if id := m.employee_from_employer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployeeFromEmployer resets all changes to the "employee_from_employer" edge.
func (m *EMPLOYEEMutation) ResetEmployeeFromEmployer() {
	m.employee_from_employer = nil
	m.clearedemployee_from_employer = false
}

// AddEmployeeOfPaymentHistoryIDs adds the "employee_of_payment_history" edge to the PAYMENT_HISTORY entity by ids.
func (m *EMPLOYEEMutation) AddEmployeeOfPaymentHistoryIDs(ids ...int) {
	if m.employee_of_payment_history == nil {
		m.employee_of_payment_history = make(map[int]struct{})
	}
	for i := range ids {
		m.employee_of_payment_history[ids[i]] = struct{}{}
	}
}

// ClearEmployeeOfPaymentHistory clears the "employee_of_payment_history" edge to the PAYMENT_HISTORY entity.
func (m *EMPLOYEEMutation) ClearEmployeeOfPaymentHistory() {
	m.clearedemployee_of_payment_history = true
}

// EmployeeOfPaymentHistoryCleared reports if the "employee_of_payment_history" edge to the PAYMENT_HISTORY entity was cleared.
func (m *EMPLOYEEMutation) EmployeeOfPaymentHistoryCleared() bool {
	return m.clearedemployee_of_payment_history
}

// RemoveEmployeeOfPaymentHistoryIDs removes the "employee_of_payment_history" edge to the PAYMENT_HISTORY entity by IDs.
func (m *EMPLOYEEMutation) RemoveEmployeeOfPaymentHistoryIDs(ids ...int) {
	if m.removedemployee_of_payment_history == nil {
		m.removedemployee_of_payment_history = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employee_of_payment_history, ids[i])
		m.removedemployee_of_payment_history[ids[i]] = struct{}{}
	}
}

// RemovedEmployeeOfPaymentHistory returns the removed IDs of the "employee_of_payment_history" edge to the PAYMENT_HISTORY entity.
func (m *EMPLOYEEMutation) RemovedEmployeeOfPaymentHistoryIDs() (ids []int) {
	for id := range m.removedemployee_of_payment_history {
		ids = append(ids, id)
	}
	return
}

// EmployeeOfPaymentHistoryIDs returns the "employee_of_payment_history" edge IDs in the mutation.
func (m *EMPLOYEEMutation) EmployeeOfPaymentHistoryIDs() (ids []int) {
	for id := range m.employee_of_payment_history {
		ids = append(ids, id)
	}
	return
}

// ResetEmployeeOfPaymentHistory resets all changes to the "employee_of_payment_history" edge.
func (m *EMPLOYEEMutation) ResetEmployeeOfPaymentHistory() {
	m.employee_of_payment_history = nil
	m.clearedemployee_of_payment_history = false
	m.removedemployee_of_payment_history = nil
}

// Where appends a list predicates to the EMPLOYEEMutation builder.
func (m *EMPLOYEEMutation) Where(ps ...predicate.EMPLOYEE) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EMPLOYEEMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EMPLOYEE).
func (m *EMPLOYEEMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EMPLOYEEMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.gid != nil {
		fields = append(fields, employee.FieldGid)
	}
	if m.employee_from_employer != nil {
		fields = append(fields, employee.FieldEmployerID)
	}
	if m.name != nil {
		fields = append(fields, employee.FieldName)
	}
	if m.position != nil {
		fields = append(fields, employee.FieldPosition)
	}
	if m.wallet != nil {
		fields = append(fields, employee.FieldWallet)
	}
	if m.payroll != nil {
		fields = append(fields, employee.FieldPayroll)
	}
	if m.employee_from_currency != nil {
		fields = append(fields, employee.FieldCryptoCurrencyID)
	}
	if m.payday != nil {
		fields = append(fields, employee.FieldPayday)
	}
	if m.employee_from_employ_type != nil {
		fields = append(fields, employee.FieldEmployTypeID)
	}
	if m.email != nil {
		fields = append(fields, employee.FieldEmail)
	}
	if m.work_start != nil {
		fields = append(fields, employee.FieldWorkStart)
	}
	if m.work_ends != nil {
		fields = append(fields, employee.FieldWorkEnds)
	}
	if m.created_at != nil {
		fields = append(fields, employee.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, employee.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, employee.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, employee.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EMPLOYEEMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldGid:
		return m.Gid()
	case employee.FieldEmployerID:
		return m.EmployerID()
	case employee.FieldName:
		return m.Name()
	case employee.FieldPosition:
		return m.Position()
	case employee.FieldWallet:
		return m.Wallet()
	case employee.FieldPayroll:
		return m.Payroll()
	case employee.FieldCryptoCurrencyID:
		return m.CryptoCurrencyID()
	case employee.FieldPayday:
		return m.Payday()
	case employee.FieldEmployTypeID:
		return m.EmployTypeID()
	case employee.FieldEmail:
		return m.Email()
	case employee.FieldWorkStart:
		return m.WorkStart()
	case employee.FieldWorkEnds:
		return m.WorkEnds()
	case employee.FieldCreatedAt:
		return m.CreatedAt()
	case employee.FieldCreatedBy:
		return m.CreatedBy()
	case employee.FieldUpdatedAt:
		return m.UpdatedAt()
	case employee.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EMPLOYEEMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldGid:
		return m.OldGid(ctx)
	case employee.FieldEmployerID:
		return m.OldEmployerID(ctx)
	case employee.FieldName:
		return m.OldName(ctx)
	case employee.FieldPosition:
		return m.OldPosition(ctx)
	case employee.FieldWallet:
		return m.OldWallet(ctx)
	case employee.FieldPayroll:
		return m.OldPayroll(ctx)
	case employee.FieldCryptoCurrencyID:
		return m.OldCryptoCurrencyID(ctx)
	case employee.FieldPayday:
		return m.OldPayday(ctx)
	case employee.FieldEmployTypeID:
		return m.OldEmployTypeID(ctx)
	case employee.FieldEmail:
		return m.OldEmail(ctx)
	case employee.FieldWorkStart:
		return m.OldWorkStart(ctx)
	case employee.FieldWorkEnds:
		return m.OldWorkEnds(ctx)
	case employee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case employee.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case employee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case employee.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown EMPLOYEE field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EMPLOYEEMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldGid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGid(v)
		return nil
	case employee.FieldEmployerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployerID(v)
		return nil
	case employee.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case employee.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case employee.FieldWallet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWallet(v)
		return nil
	case employee.FieldPayroll:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayroll(v)
		return nil
	case employee.FieldCryptoCurrencyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCryptoCurrencyID(v)
		return nil
	case employee.FieldPayday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayday(v)
		return nil
	case employee.FieldEmployTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployTypeID(v)
		return nil
	case employee.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case employee.FieldWorkStart:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkStart(v)
		return nil
	case employee.FieldWorkEnds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkEnds(v)
		return nil
	case employee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case employee.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case employee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case employee.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown EMPLOYEE field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EMPLOYEEMutation) AddedFields() []string {
	var fields []string
	if m.addpayroll != nil {
		fields = append(fields, employee.FieldPayroll)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EMPLOYEEMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldPayroll:
		return m.AddedPayroll()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EMPLOYEEMutation) AddField(name string, value ent.Value) error {
	switch name {
	case employee.FieldPayroll:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayroll(v)
		return nil
	}
	return fmt.Errorf("unknown EMPLOYEE numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EMPLOYEEMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldEmployerID) {
		fields = append(fields, employee.FieldEmployerID)
	}
	if m.FieldCleared(employee.FieldCryptoCurrencyID) {
		fields = append(fields, employee.FieldCryptoCurrencyID)
	}
	if m.FieldCleared(employee.FieldEmployTypeID) {
		fields = append(fields, employee.FieldEmployTypeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EMPLOYEEMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EMPLOYEEMutation) ClearField(name string) error {
	switch name {
	case employee.FieldEmployerID:
		m.ClearEmployerID()
		return nil
	case employee.FieldCryptoCurrencyID:
		m.ClearCryptoCurrencyID()
		return nil
	case employee.FieldEmployTypeID:
		m.ClearEmployTypeID()
		return nil
	}
	return fmt.Errorf("unknown EMPLOYEE nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EMPLOYEEMutation) ResetField(name string) error {
	switch name {
	case employee.FieldGid:
		m.ResetGid()
		return nil
	case employee.FieldEmployerID:
		m.ResetEmployerID()
		return nil
	case employee.FieldName:
		m.ResetName()
		return nil
	case employee.FieldPosition:
		m.ResetPosition()
		return nil
	case employee.FieldWallet:
		m.ResetWallet()
		return nil
	case employee.FieldPayroll:
		m.ResetPayroll()
		return nil
	case employee.FieldCryptoCurrencyID:
		m.ResetCryptoCurrencyID()
		return nil
	case employee.FieldPayday:
		m.ResetPayday()
		return nil
	case employee.FieldEmployTypeID:
		m.ResetEmployTypeID()
		return nil
	case employee.FieldEmail:
		m.ResetEmail()
		return nil
	case employee.FieldWorkStart:
		m.ResetWorkStart()
		return nil
	case employee.FieldWorkEnds:
		m.ResetWorkEnds()
		return nil
	case employee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case employee.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case employee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case employee.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown EMPLOYEE field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EMPLOYEEMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.employee_from_currency != nil {
		edges = append(edges, employee.EdgeEmployeeFromCurrency)
	}
	if m.employee_from_employ_type != nil {
		edges = append(edges, employee.EdgeEmployeeFromEmployType)
	}
	if m.employee_from_employer != nil {
		edges = append(edges, employee.EdgeEmployeeFromEmployer)
	}
	if m.employee_of_payment_history != nil {
		edges = append(edges, employee.EdgeEmployeeOfPaymentHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EMPLOYEEMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployeeFromCurrency:
		if id := m.employee_from_currency; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeEmployeeFromEmployType:
		if id := m.employee_from_employ_type; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeEmployeeFromEmployer:
		if id := m.employee_from_employer; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeEmployeeOfPaymentHistory:
		ids := make([]ent.Value, 0, len(m.employee_of_payment_history))
		for id := range m.employee_of_payment_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EMPLOYEEMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedemployee_of_payment_history != nil {
		edges = append(edges, employee.EdgeEmployeeOfPaymentHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EMPLOYEEMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployeeOfPaymentHistory:
		ids := make([]ent.Value, 0, len(m.removedemployee_of_payment_history))
		for id := range m.removedemployee_of_payment_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EMPLOYEEMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedemployee_from_currency {
		edges = append(edges, employee.EdgeEmployeeFromCurrency)
	}
	if m.clearedemployee_from_employ_type {
		edges = append(edges, employee.EdgeEmployeeFromEmployType)
	}
	if m.clearedemployee_from_employer {
		edges = append(edges, employee.EdgeEmployeeFromEmployer)
	}
	if m.clearedemployee_of_payment_history {
		edges = append(edges, employee.EdgeEmployeeOfPaymentHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EMPLOYEEMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeEmployeeFromCurrency:
		return m.clearedemployee_from_currency
	case employee.EdgeEmployeeFromEmployType:
		return m.clearedemployee_from_employ_type
	case employee.EdgeEmployeeFromEmployer:
		return m.clearedemployee_from_employer
	case employee.EdgeEmployeeOfPaymentHistory:
		return m.clearedemployee_of_payment_history
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EMPLOYEEMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeEmployeeFromCurrency:
		m.ClearEmployeeFromCurrency()
		return nil
	case employee.EdgeEmployeeFromEmployType:
		m.ClearEmployeeFromEmployType()
		return nil
	case employee.EdgeEmployeeFromEmployer:
		m.ClearEmployeeFromEmployer()
		return nil
	}
	return fmt.Errorf("unknown EMPLOYEE unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EMPLOYEEMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeEmployeeFromCurrency:
		m.ResetEmployeeFromCurrency()
		return nil
	case employee.EdgeEmployeeFromEmployType:
		m.ResetEmployeeFromEmployType()
		return nil
	case employee.EdgeEmployeeFromEmployer:
		m.ResetEmployeeFromEmployer()
		return nil
	case employee.EdgeEmployeeOfPaymentHistory:
		m.ResetEmployeeOfPaymentHistory()
		return nil
	}
	return fmt.Errorf("unknown EMPLOYEE edge %s", name)
}

// EMPLOYERMutation represents an operation that mutates the EMPLOYER nodes in the graph.
type EMPLOYERMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	username                    *string
	password                    *string
	gid                         *string
	corp_name                   *string
	corp_email                  *string
	wallet                      *string
	created_at                  *time.Time
	created_by                  *string
	updated_at                  *time.Time
	updated_by                  *string
	clearedFields               map[string]struct{}
	employer_of_employee        map[int]struct{}
	removedemployer_of_employee map[int]struct{}
	clearedemployer_of_employee bool
	done                        bool
	oldValue                    func(context.Context) (*EMPLOYER, error)
	predicates                  []predicate.EMPLOYER
}

var _ ent.Mutation = (*EMPLOYERMutation)(nil)

// employerOption allows management of the mutation configuration using functional options.
type employerOption func(*EMPLOYERMutation)

// newEMPLOYERMutation creates new mutation for the EMPLOYER entity.
func newEMPLOYERMutation(c config, op Op, opts ...employerOption) *EMPLOYERMutation {
	m := &EMPLOYERMutation{
		config:        c,
		op:            op,
		typ:           TypeEMPLOYER,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEMPLOYERID sets the ID field of the mutation.
func withEMPLOYERID(id int) employerOption {
	return func(m *EMPLOYERMutation) {
		var (
			err   error
			once  sync.Once
			value *EMPLOYER
		)
		m.oldValue = func(ctx context.Context) (*EMPLOYER, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EMPLOYER.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEMPLOYER sets the old EMPLOYER of the mutation.
func withEMPLOYER(node *EMPLOYER) employerOption {
	return func(m *EMPLOYERMutation) {
		m.oldValue = func(context.Context) (*EMPLOYER, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EMPLOYERMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EMPLOYERMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EMPLOYER entities.
func (m *EMPLOYERMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EMPLOYERMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EMPLOYERMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EMPLOYER.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *EMPLOYERMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *EMPLOYERMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the EMPLOYER entity.
// If the EMPLOYER object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYERMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *EMPLOYERMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *EMPLOYERMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *EMPLOYERMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the EMPLOYER entity.
// If the EMPLOYER object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYERMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *EMPLOYERMutation) ResetPassword() {
	m.password = nil
}

// SetGid sets the "gid" field.
func (m *EMPLOYERMutation) SetGid(s string) {
	m.gid = &s
}

// Gid returns the value of the "gid" field in the mutation.
func (m *EMPLOYERMutation) Gid() (r string, exists bool) {
	v := m.gid
	if v == nil {
		return
	}
	return *v, true
}

// OldGid returns the old "gid" field's value of the EMPLOYER entity.
// If the EMPLOYER object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYERMutation) OldGid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGid: %w", err)
	}
	return oldValue.Gid, nil
}

// ResetGid resets all changes to the "gid" field.
func (m *EMPLOYERMutation) ResetGid() {
	m.gid = nil
}

// SetCorpName sets the "corp_name" field.
func (m *EMPLOYERMutation) SetCorpName(s string) {
	m.corp_name = &s
}

// CorpName returns the value of the "corp_name" field in the mutation.
func (m *EMPLOYERMutation) CorpName() (r string, exists bool) {
	v := m.corp_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCorpName returns the old "corp_name" field's value of the EMPLOYER entity.
// If the EMPLOYER object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYERMutation) OldCorpName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorpName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorpName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorpName: %w", err)
	}
	return oldValue.CorpName, nil
}

// ResetCorpName resets all changes to the "corp_name" field.
func (m *EMPLOYERMutation) ResetCorpName() {
	m.corp_name = nil
}

// SetCorpEmail sets the "corp_email" field.
func (m *EMPLOYERMutation) SetCorpEmail(s string) {
	m.corp_email = &s
}

// CorpEmail returns the value of the "corp_email" field in the mutation.
func (m *EMPLOYERMutation) CorpEmail() (r string, exists bool) {
	v := m.corp_email
	if v == nil {
		return
	}
	return *v, true
}

// OldCorpEmail returns the old "corp_email" field's value of the EMPLOYER entity.
// If the EMPLOYER object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYERMutation) OldCorpEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorpEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorpEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorpEmail: %w", err)
	}
	return oldValue.CorpEmail, nil
}

// ResetCorpEmail resets all changes to the "corp_email" field.
func (m *EMPLOYERMutation) ResetCorpEmail() {
	m.corp_email = nil
}

// SetWallet sets the "wallet" field.
func (m *EMPLOYERMutation) SetWallet(s string) {
	m.wallet = &s
}

// Wallet returns the value of the "wallet" field in the mutation.
func (m *EMPLOYERMutation) Wallet() (r string, exists bool) {
	v := m.wallet
	if v == nil {
		return
	}
	return *v, true
}

// OldWallet returns the old "wallet" field's value of the EMPLOYER entity.
// If the EMPLOYER object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYERMutation) OldWallet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWallet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWallet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWallet: %w", err)
	}
	return oldValue.Wallet, nil
}

// ResetWallet resets all changes to the "wallet" field.
func (m *EMPLOYERMutation) ResetWallet() {
	m.wallet = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EMPLOYERMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EMPLOYERMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EMPLOYER entity.
// If the EMPLOYER object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYERMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EMPLOYERMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EMPLOYERMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EMPLOYERMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EMPLOYER entity.
// If the EMPLOYER object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYERMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EMPLOYERMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EMPLOYERMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EMPLOYERMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EMPLOYER entity.
// If the EMPLOYER object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYERMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EMPLOYERMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EMPLOYERMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EMPLOYERMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EMPLOYER entity.
// If the EMPLOYER object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYERMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EMPLOYERMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// AddEmployerOfEmployeeIDs adds the "employer_of_employee" edge to the EMPLOYEE entity by ids.
func (m *EMPLOYERMutation) AddEmployerOfEmployeeIDs(ids ...int) {
	if m.employer_of_employee == nil {
		m.employer_of_employee = make(map[int]struct{})
	}
	for i := range ids {
		m.employer_of_employee[ids[i]] = struct{}{}
	}
}

// ClearEmployerOfEmployee clears the "employer_of_employee" edge to the EMPLOYEE entity.
func (m *EMPLOYERMutation) ClearEmployerOfEmployee() {
	m.clearedemployer_of_employee = true
}

// EmployerOfEmployeeCleared reports if the "employer_of_employee" edge to the EMPLOYEE entity was cleared.
func (m *EMPLOYERMutation) EmployerOfEmployeeCleared() bool {
	return m.clearedemployer_of_employee
}

// RemoveEmployerOfEmployeeIDs removes the "employer_of_employee" edge to the EMPLOYEE entity by IDs.
func (m *EMPLOYERMutation) RemoveEmployerOfEmployeeIDs(ids ...int) {
	if m.removedemployer_of_employee == nil {
		m.removedemployer_of_employee = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employer_of_employee, ids[i])
		m.removedemployer_of_employee[ids[i]] = struct{}{}
	}
}

// RemovedEmployerOfEmployee returns the removed IDs of the "employer_of_employee" edge to the EMPLOYEE entity.
func (m *EMPLOYERMutation) RemovedEmployerOfEmployeeIDs() (ids []int) {
	for id := range m.removedemployer_of_employee {
		ids = append(ids, id)
	}
	return
}

// EmployerOfEmployeeIDs returns the "employer_of_employee" edge IDs in the mutation.
func (m *EMPLOYERMutation) EmployerOfEmployeeIDs() (ids []int) {
	for id := range m.employer_of_employee {
		ids = append(ids, id)
	}
	return
}

// ResetEmployerOfEmployee resets all changes to the "employer_of_employee" edge.
func (m *EMPLOYERMutation) ResetEmployerOfEmployee() {
	m.employer_of_employee = nil
	m.clearedemployer_of_employee = false
	m.removedemployer_of_employee = nil
}

// Where appends a list predicates to the EMPLOYERMutation builder.
func (m *EMPLOYERMutation) Where(ps ...predicate.EMPLOYER) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EMPLOYERMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EMPLOYER).
func (m *EMPLOYERMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EMPLOYERMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.username != nil {
		fields = append(fields, employer.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, employer.FieldPassword)
	}
	if m.gid != nil {
		fields = append(fields, employer.FieldGid)
	}
	if m.corp_name != nil {
		fields = append(fields, employer.FieldCorpName)
	}
	if m.corp_email != nil {
		fields = append(fields, employer.FieldCorpEmail)
	}
	if m.wallet != nil {
		fields = append(fields, employer.FieldWallet)
	}
	if m.created_at != nil {
		fields = append(fields, employer.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, employer.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, employer.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, employer.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EMPLOYERMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employer.FieldUsername:
		return m.Username()
	case employer.FieldPassword:
		return m.Password()
	case employer.FieldGid:
		return m.Gid()
	case employer.FieldCorpName:
		return m.CorpName()
	case employer.FieldCorpEmail:
		return m.CorpEmail()
	case employer.FieldWallet:
		return m.Wallet()
	case employer.FieldCreatedAt:
		return m.CreatedAt()
	case employer.FieldCreatedBy:
		return m.CreatedBy()
	case employer.FieldUpdatedAt:
		return m.UpdatedAt()
	case employer.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EMPLOYERMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employer.FieldUsername:
		return m.OldUsername(ctx)
	case employer.FieldPassword:
		return m.OldPassword(ctx)
	case employer.FieldGid:
		return m.OldGid(ctx)
	case employer.FieldCorpName:
		return m.OldCorpName(ctx)
	case employer.FieldCorpEmail:
		return m.OldCorpEmail(ctx)
	case employer.FieldWallet:
		return m.OldWallet(ctx)
	case employer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case employer.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case employer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case employer.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown EMPLOYER field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EMPLOYERMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employer.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case employer.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case employer.FieldGid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGid(v)
		return nil
	case employer.FieldCorpName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorpName(v)
		return nil
	case employer.FieldCorpEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorpEmail(v)
		return nil
	case employer.FieldWallet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWallet(v)
		return nil
	case employer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case employer.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case employer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case employer.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown EMPLOYER field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EMPLOYERMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EMPLOYERMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EMPLOYERMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EMPLOYER numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EMPLOYERMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EMPLOYERMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EMPLOYERMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EMPLOYER nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EMPLOYERMutation) ResetField(name string) error {
	switch name {
	case employer.FieldUsername:
		m.ResetUsername()
		return nil
	case employer.FieldPassword:
		m.ResetPassword()
		return nil
	case employer.FieldGid:
		m.ResetGid()
		return nil
	case employer.FieldCorpName:
		m.ResetCorpName()
		return nil
	case employer.FieldCorpEmail:
		m.ResetCorpEmail()
		return nil
	case employer.FieldWallet:
		m.ResetWallet()
		return nil
	case employer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case employer.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case employer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case employer.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown EMPLOYER field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EMPLOYERMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employer_of_employee != nil {
		edges = append(edges, employer.EdgeEmployerOfEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EMPLOYERMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employer.EdgeEmployerOfEmployee:
		ids := make([]ent.Value, 0, len(m.employer_of_employee))
		for id := range m.employer_of_employee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EMPLOYERMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemployer_of_employee != nil {
		edges = append(edges, employer.EdgeEmployerOfEmployee)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EMPLOYERMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employer.EdgeEmployerOfEmployee:
		ids := make([]ent.Value, 0, len(m.removedemployer_of_employee))
		for id := range m.removedemployer_of_employee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EMPLOYERMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedemployer_of_employee {
		edges = append(edges, employer.EdgeEmployerOfEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EMPLOYERMutation) EdgeCleared(name string) bool {
	switch name {
	case employer.EdgeEmployerOfEmployee:
		return m.clearedemployer_of_employee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EMPLOYERMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown EMPLOYER unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EMPLOYERMutation) ResetEdge(name string) error {
	switch name {
	case employer.EdgeEmployerOfEmployee:
		m.ResetEmployerOfEmployee()
		return nil
	}
	return fmt.Errorf("unknown EMPLOYER edge %s", name)
}

// EMPLOYTYPEMutation represents an operation that mutates the EMPLOY_TYPE nodes in the graph.
type EMPLOYTYPEMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	is_permanent                   *string
	pay_freq                       *string
	clearedFields                  map[string]struct{}
	employ_type_of_employee        map[int]struct{}
	removedemploy_type_of_employee map[int]struct{}
	clearedemploy_type_of_employee bool
	done                           bool
	oldValue                       func(context.Context) (*EMPLOY_TYPE, error)
	predicates                     []predicate.EMPLOY_TYPE
}

var _ ent.Mutation = (*EMPLOYTYPEMutation)(nil)

// employTYPEOption allows management of the mutation configuration using functional options.
type employTYPEOption func(*EMPLOYTYPEMutation)

// newEMPLOYTYPEMutation creates new mutation for the EMPLOY_TYPE entity.
func newEMPLOYTYPEMutation(c config, op Op, opts ...employTYPEOption) *EMPLOYTYPEMutation {
	m := &EMPLOYTYPEMutation{
		config:        c,
		op:            op,
		typ:           TypeEMPLOY_TYPE,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEMPLOY_TYPEID sets the ID field of the mutation.
func withEMPLOY_TYPEID(id int) employTYPEOption {
	return func(m *EMPLOYTYPEMutation) {
		var (
			err   error
			once  sync.Once
			value *EMPLOY_TYPE
		)
		m.oldValue = func(ctx context.Context) (*EMPLOY_TYPE, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EMPLOY_TYPE.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEMPLOY_TYPE sets the old EMPLOY_TYPE of the mutation.
func withEMPLOY_TYPE(node *EMPLOY_TYPE) employTYPEOption {
	return func(m *EMPLOYTYPEMutation) {
		m.oldValue = func(context.Context) (*EMPLOY_TYPE, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EMPLOYTYPEMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EMPLOYTYPEMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EMPLOY_TYPE entities.
func (m *EMPLOYTYPEMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EMPLOYTYPEMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EMPLOYTYPEMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EMPLOY_TYPE.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsPermanent sets the "is_permanent" field.
func (m *EMPLOYTYPEMutation) SetIsPermanent(s string) {
	m.is_permanent = &s
}

// IsPermanent returns the value of the "is_permanent" field in the mutation.
func (m *EMPLOYTYPEMutation) IsPermanent() (r string, exists bool) {
	v := m.is_permanent
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPermanent returns the old "is_permanent" field's value of the EMPLOY_TYPE entity.
// If the EMPLOY_TYPE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYTYPEMutation) OldIsPermanent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPermanent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPermanent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPermanent: %w", err)
	}
	return oldValue.IsPermanent, nil
}

// ResetIsPermanent resets all changes to the "is_permanent" field.
func (m *EMPLOYTYPEMutation) ResetIsPermanent() {
	m.is_permanent = nil
}

// SetPayFreq sets the "pay_freq" field.
func (m *EMPLOYTYPEMutation) SetPayFreq(s string) {
	m.pay_freq = &s
}

// PayFreq returns the value of the "pay_freq" field in the mutation.
func (m *EMPLOYTYPEMutation) PayFreq() (r string, exists bool) {
	v := m.pay_freq
	if v == nil {
		return
	}
	return *v, true
}

// OldPayFreq returns the old "pay_freq" field's value of the EMPLOY_TYPE entity.
// If the EMPLOY_TYPE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EMPLOYTYPEMutation) OldPayFreq(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayFreq is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayFreq requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayFreq: %w", err)
	}
	return oldValue.PayFreq, nil
}

// ResetPayFreq resets all changes to the "pay_freq" field.
func (m *EMPLOYTYPEMutation) ResetPayFreq() {
	m.pay_freq = nil
}

// AddEmployTypeOfEmployeeIDs adds the "employ_type_of_employee" edge to the EMPLOYEE entity by ids.
func (m *EMPLOYTYPEMutation) AddEmployTypeOfEmployeeIDs(ids ...int) {
	if m.employ_type_of_employee == nil {
		m.employ_type_of_employee = make(map[int]struct{})
	}
	for i := range ids {
		m.employ_type_of_employee[ids[i]] = struct{}{}
	}
}

// ClearEmployTypeOfEmployee clears the "employ_type_of_employee" edge to the EMPLOYEE entity.
func (m *EMPLOYTYPEMutation) ClearEmployTypeOfEmployee() {
	m.clearedemploy_type_of_employee = true
}

// EmployTypeOfEmployeeCleared reports if the "employ_type_of_employee" edge to the EMPLOYEE entity was cleared.
func (m *EMPLOYTYPEMutation) EmployTypeOfEmployeeCleared() bool {
	return m.clearedemploy_type_of_employee
}

// RemoveEmployTypeOfEmployeeIDs removes the "employ_type_of_employee" edge to the EMPLOYEE entity by IDs.
func (m *EMPLOYTYPEMutation) RemoveEmployTypeOfEmployeeIDs(ids ...int) {
	if m.removedemploy_type_of_employee == nil {
		m.removedemploy_type_of_employee = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employ_type_of_employee, ids[i])
		m.removedemploy_type_of_employee[ids[i]] = struct{}{}
	}
}

// RemovedEmployTypeOfEmployee returns the removed IDs of the "employ_type_of_employee" edge to the EMPLOYEE entity.
func (m *EMPLOYTYPEMutation) RemovedEmployTypeOfEmployeeIDs() (ids []int) {
	for id := range m.removedemploy_type_of_employee {
		ids = append(ids, id)
	}
	return
}

// EmployTypeOfEmployeeIDs returns the "employ_type_of_employee" edge IDs in the mutation.
func (m *EMPLOYTYPEMutation) EmployTypeOfEmployeeIDs() (ids []int) {
	for id := range m.employ_type_of_employee {
		ids = append(ids, id)
	}
	return
}

// ResetEmployTypeOfEmployee resets all changes to the "employ_type_of_employee" edge.
func (m *EMPLOYTYPEMutation) ResetEmployTypeOfEmployee() {
	m.employ_type_of_employee = nil
	m.clearedemploy_type_of_employee = false
	m.removedemploy_type_of_employee = nil
}

// Where appends a list predicates to the EMPLOYTYPEMutation builder.
func (m *EMPLOYTYPEMutation) Where(ps ...predicate.EMPLOY_TYPE) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EMPLOYTYPEMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EMPLOY_TYPE).
func (m *EMPLOYTYPEMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EMPLOYTYPEMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.is_permanent != nil {
		fields = append(fields, employ_type.FieldIsPermanent)
	}
	if m.pay_freq != nil {
		fields = append(fields, employ_type.FieldPayFreq)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EMPLOYTYPEMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employ_type.FieldIsPermanent:
		return m.IsPermanent()
	case employ_type.FieldPayFreq:
		return m.PayFreq()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EMPLOYTYPEMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employ_type.FieldIsPermanent:
		return m.OldIsPermanent(ctx)
	case employ_type.FieldPayFreq:
		return m.OldPayFreq(ctx)
	}
	return nil, fmt.Errorf("unknown EMPLOY_TYPE field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EMPLOYTYPEMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employ_type.FieldIsPermanent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPermanent(v)
		return nil
	case employ_type.FieldPayFreq:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayFreq(v)
		return nil
	}
	return fmt.Errorf("unknown EMPLOY_TYPE field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EMPLOYTYPEMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EMPLOYTYPEMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EMPLOYTYPEMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EMPLOY_TYPE numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EMPLOYTYPEMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EMPLOYTYPEMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EMPLOYTYPEMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EMPLOY_TYPE nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EMPLOYTYPEMutation) ResetField(name string) error {
	switch name {
	case employ_type.FieldIsPermanent:
		m.ResetIsPermanent()
		return nil
	case employ_type.FieldPayFreq:
		m.ResetPayFreq()
		return nil
	}
	return fmt.Errorf("unknown EMPLOY_TYPE field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EMPLOYTYPEMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employ_type_of_employee != nil {
		edges = append(edges, employ_type.EdgeEmployTypeOfEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EMPLOYTYPEMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employ_type.EdgeEmployTypeOfEmployee:
		ids := make([]ent.Value, 0, len(m.employ_type_of_employee))
		for id := range m.employ_type_of_employee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EMPLOYTYPEMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemploy_type_of_employee != nil {
		edges = append(edges, employ_type.EdgeEmployTypeOfEmployee)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EMPLOYTYPEMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employ_type.EdgeEmployTypeOfEmployee:
		ids := make([]ent.Value, 0, len(m.removedemploy_type_of_employee))
		for id := range m.removedemploy_type_of_employee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EMPLOYTYPEMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedemploy_type_of_employee {
		edges = append(edges, employ_type.EdgeEmployTypeOfEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EMPLOYTYPEMutation) EdgeCleared(name string) bool {
	switch name {
	case employ_type.EdgeEmployTypeOfEmployee:
		return m.clearedemploy_type_of_employee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EMPLOYTYPEMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown EMPLOY_TYPE unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EMPLOYTYPEMutation) ResetEdge(name string) error {
	switch name {
	case employ_type.EdgeEmployTypeOfEmployee:
		m.ResetEmployTypeOfEmployee()
		return nil
	}
	return fmt.Errorf("unknown EMPLOY_TYPE edge %s", name)
}

// PAYMENTHISTORYMutation represents an operation that mutates the PAYMENT_HISTORY nodes in the graph.
type PAYMENTHISTORYMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	created_at                           *time.Time
	created_by                           *string
	clearedFields                        map[string]struct{}
	payment_history_from_employee        *int
	clearedpayment_history_from_employee bool
	done                                 bool
	oldValue                             func(context.Context) (*PAYMENT_HISTORY, error)
	predicates                           []predicate.PAYMENT_HISTORY
}

var _ ent.Mutation = (*PAYMENTHISTORYMutation)(nil)

// paymentHISTORYOption allows management of the mutation configuration using functional options.
type paymentHISTORYOption func(*PAYMENTHISTORYMutation)

// newPAYMENTHISTORYMutation creates new mutation for the PAYMENT_HISTORY entity.
func newPAYMENTHISTORYMutation(c config, op Op, opts ...paymentHISTORYOption) *PAYMENTHISTORYMutation {
	m := &PAYMENTHISTORYMutation{
		config:        c,
		op:            op,
		typ:           TypePAYMENT_HISTORY,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPAYMENT_HISTORYID sets the ID field of the mutation.
func withPAYMENT_HISTORYID(id int) paymentHISTORYOption {
	return func(m *PAYMENTHISTORYMutation) {
		var (
			err   error
			once  sync.Once
			value *PAYMENT_HISTORY
		)
		m.oldValue = func(ctx context.Context) (*PAYMENT_HISTORY, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PAYMENT_HISTORY.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPAYMENT_HISTORY sets the old PAYMENT_HISTORY of the mutation.
func withPAYMENT_HISTORY(node *PAYMENT_HISTORY) paymentHISTORYOption {
	return func(m *PAYMENTHISTORYMutation) {
		m.oldValue = func(context.Context) (*PAYMENT_HISTORY, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PAYMENTHISTORYMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PAYMENTHISTORYMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PAYMENT_HISTORY entities.
func (m *PAYMENTHISTORYMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PAYMENTHISTORYMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PAYMENTHISTORYMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PAYMENT_HISTORY.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "employee_id" field.
func (m *PAYMENTHISTORYMutation) SetEmployeeID(i int) {
	m.payment_history_from_employee = &i
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *PAYMENTHISTORYMutation) EmployeeID() (r int, exists bool) {
	v := m.payment_history_from_employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the PAYMENT_HISTORY entity.
// If the PAYMENT_HISTORY object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PAYMENTHISTORYMutation) OldEmployeeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *PAYMENTHISTORYMutation) ClearEmployeeID() {
	m.payment_history_from_employee = nil
	m.clearedFields[payment_history.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *PAYMENTHISTORYMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[payment_history.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *PAYMENTHISTORYMutation) ResetEmployeeID() {
	m.payment_history_from_employee = nil
	delete(m.clearedFields, payment_history.FieldEmployeeID)
}

// SetCreatedAt sets the "created_at" field.
func (m *PAYMENTHISTORYMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PAYMENTHISTORYMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PAYMENT_HISTORY entity.
// If the PAYMENT_HISTORY object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PAYMENTHISTORYMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PAYMENTHISTORYMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PAYMENTHISTORYMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PAYMENTHISTORYMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PAYMENT_HISTORY entity.
// If the PAYMENT_HISTORY object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PAYMENTHISTORYMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PAYMENTHISTORYMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetPaymentHistoryFromEmployeeID sets the "payment_history_from_employee" edge to the EMPLOYEE entity by id.
func (m *PAYMENTHISTORYMutation) SetPaymentHistoryFromEmployeeID(id int) {
	m.payment_history_from_employee = &id
}

// ClearPaymentHistoryFromEmployee clears the "payment_history_from_employee" edge to the EMPLOYEE entity.
func (m *PAYMENTHISTORYMutation) ClearPaymentHistoryFromEmployee() {
	m.clearedpayment_history_from_employee = true
}

// PaymentHistoryFromEmployeeCleared reports if the "payment_history_from_employee" edge to the EMPLOYEE entity was cleared.
func (m *PAYMENTHISTORYMutation) PaymentHistoryFromEmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedpayment_history_from_employee
}

// PaymentHistoryFromEmployeeID returns the "payment_history_from_employee" edge ID in the mutation.
func (m *PAYMENTHISTORYMutation) PaymentHistoryFromEmployeeID() (id int, exists bool) {
	if m.payment_history_from_employee != nil {
		return *m.payment_history_from_employee, true
	}
	return
}

// PaymentHistoryFromEmployeeIDs returns the "payment_history_from_employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentHistoryFromEmployeeID instead. It exists only for internal usage by the builders.
func (m *PAYMENTHISTORYMutation) PaymentHistoryFromEmployeeIDs() (ids []int) {
	if id := m.payment_history_from_employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaymentHistoryFromEmployee resets all changes to the "payment_history_from_employee" edge.
func (m *PAYMENTHISTORYMutation) ResetPaymentHistoryFromEmployee() {
	m.payment_history_from_employee = nil
	m.clearedpayment_history_from_employee = false
}

// Where appends a list predicates to the PAYMENTHISTORYMutation builder.
func (m *PAYMENTHISTORYMutation) Where(ps ...predicate.PAYMENT_HISTORY) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PAYMENTHISTORYMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PAYMENT_HISTORY).
func (m *PAYMENTHISTORYMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PAYMENTHISTORYMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.payment_history_from_employee != nil {
		fields = append(fields, payment_history.FieldEmployeeID)
	}
	if m.created_at != nil {
		fields = append(fields, payment_history.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, payment_history.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PAYMENTHISTORYMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment_history.FieldEmployeeID:
		return m.EmployeeID()
	case payment_history.FieldCreatedAt:
		return m.CreatedAt()
	case payment_history.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PAYMENTHISTORYMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment_history.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case payment_history.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case payment_history.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown PAYMENT_HISTORY field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PAYMENTHISTORYMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment_history.FieldEmployeeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case payment_history.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case payment_history.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown PAYMENT_HISTORY field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PAYMENTHISTORYMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PAYMENTHISTORYMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PAYMENTHISTORYMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PAYMENT_HISTORY numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PAYMENTHISTORYMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payment_history.FieldEmployeeID) {
		fields = append(fields, payment_history.FieldEmployeeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PAYMENTHISTORYMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PAYMENTHISTORYMutation) ClearField(name string) error {
	switch name {
	case payment_history.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	}
	return fmt.Errorf("unknown PAYMENT_HISTORY nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PAYMENTHISTORYMutation) ResetField(name string) error {
	switch name {
	case payment_history.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case payment_history.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case payment_history.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown PAYMENT_HISTORY field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PAYMENTHISTORYMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payment_history_from_employee != nil {
		edges = append(edges, payment_history.EdgePaymentHistoryFromEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PAYMENTHISTORYMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment_history.EdgePaymentHistoryFromEmployee:
		if id := m.payment_history_from_employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PAYMENTHISTORYMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PAYMENTHISTORYMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PAYMENTHISTORYMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpayment_history_from_employee {
		edges = append(edges, payment_history.EdgePaymentHistoryFromEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PAYMENTHISTORYMutation) EdgeCleared(name string) bool {
	switch name {
	case payment_history.EdgePaymentHistoryFromEmployee:
		return m.clearedpayment_history_from_employee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PAYMENTHISTORYMutation) ClearEdge(name string) error {
	switch name {
	case payment_history.EdgePaymentHistoryFromEmployee:
		m.ClearPaymentHistoryFromEmployee()
		return nil
	}
	return fmt.Errorf("unknown PAYMENT_HISTORY unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PAYMENTHISTORYMutation) ResetEdge(name string) error {
	switch name {
	case payment_history.EdgePaymentHistoryFromEmployee:
		m.ResetPaymentHistoryFromEmployee()
		return nil
	}
	return fmt.Errorf("unknown PAYMENT_HISTORY edge %s", name)
}

// TrLogMutation represents an operation that mutates the Tr_log nodes in the graph.
type TrLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	tr_type       *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tr_log, error)
	predicates    []predicate.Tr_log
}

var _ ent.Mutation = (*TrLogMutation)(nil)

// trLogOption allows management of the mutation configuration using functional options.
type trLogOption func(*TrLogMutation)

// newTrLogMutation creates new mutation for the Tr_log entity.
func newTrLogMutation(c config, op Op, opts ...trLogOption) *TrLogMutation {
	m := &TrLogMutation{
		config:        c,
		op:            op,
		typ:           TypeTr_log,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTr_logID sets the ID field of the mutation.
func withTr_logID(id int) trLogOption {
	return func(m *TrLogMutation) {
		var (
			err   error
			once  sync.Once
			value *Tr_log
		)
		m.oldValue = func(ctx context.Context) (*Tr_log, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tr_log.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTr_log sets the old Tr_log of the mutation.
func withTr_log(node *Tr_log) trLogOption {
	return func(m *TrLogMutation) {
		m.oldValue = func(context.Context) (*Tr_log, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tr_log entities.
func (m *TrLogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tr_log.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTrType sets the "tr_type" field.
func (m *TrLogMutation) SetTrType(s string) {
	m.tr_type = &s
}

// TrType returns the value of the "tr_type" field in the mutation.
func (m *TrLogMutation) TrType() (r string, exists bool) {
	v := m.tr_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTrType returns the old "tr_type" field's value of the Tr_log entity.
// If the Tr_log object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrLogMutation) OldTrType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrType: %w", err)
	}
	return oldValue.TrType, nil
}

// ResetTrType resets all changes to the "tr_type" field.
func (m *TrLogMutation) ResetTrType() {
	m.tr_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TrLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tr_log entity.
// If the Tr_log object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the TrLogMutation builder.
func (m *TrLogMutation) Where(ps ...predicate.Tr_log) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TrLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tr_log).
func (m *TrLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrLogMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tr_type != nil {
		fields = append(fields, tr_log.FieldTrType)
	}
	if m.created_at != nil {
		fields = append(fields, tr_log.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tr_log.FieldTrType:
		return m.TrType()
	case tr_log.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tr_log.FieldTrType:
		return m.OldTrType(ctx)
	case tr_log.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tr_log field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tr_log.FieldTrType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrType(v)
		return nil
	case tr_log.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tr_log field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tr_log numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tr_log nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrLogMutation) ResetField(name string) error {
	switch name {
	case tr_log.FieldTrType:
		m.ResetTrType()
		return nil
	case tr_log.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tr_log field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tr_log unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tr_log edge %s", name)
}
