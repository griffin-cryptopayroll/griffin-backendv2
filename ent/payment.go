// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"griffin-dao/ent/crypto_currency"
	"griffin-dao/ent/employee"
	"griffin-dao/ent/employer"
	"griffin-dao/ent/payment"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// PAYMENT is the model entity for the PAYMENT schema.
type PAYMENT struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// EmployeeID holds the value of the "employee_id" field.
	EmployeeID int `json:"employee_id,omitempty"`
	// EmployerID holds the value of the "employer_id" field.
	EmployerID int `json:"employer_id,omitempty"`
	// PaymentScheduled holds the value of the "payment_scheduled" field.
	PaymentScheduled time.Time `json:"payment_scheduled,omitempty"`
	// PaymentExecuted holds the value of the "payment_executed" field.
	PaymentExecuted time.Time `json:"payment_executed,omitempty"`
	// PaymentAmount holds the value of the "payment_amount" field.
	PaymentAmount float64 `json:"payment_amount,omitempty"`
	// CryptoCurrencyID holds the value of the "crypto_currency_id" field.
	CryptoCurrencyID int `json:"crypto_currency_id,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the PAYMENTQuery when eager-loading is set.
	Edges PAYMENTEdges `json:"edges"`
}

// PAYMENTEdges holds the relations/edges for other nodes in the graph.
type PAYMENTEdges struct {
	// PaymentFromEmployer holds the value of the payment_from_employer edge.
	PaymentFromEmployer *EMPLOYER `json:"payment_from_employer,omitempty"`
	// PaymentFromEmployee holds the value of the payment_from_employee edge.
	PaymentFromEmployee *EMPLOYEE `json:"payment_from_employee,omitempty"`
	// PaymentFromCurrency holds the value of the payment_from_currency edge.
	PaymentFromCurrency *CRYPTO_CURRENCY `json:"payment_from_currency,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [3]bool
}

// PaymentFromEmployerOrErr returns the PaymentFromEmployer value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e PAYMENTEdges) PaymentFromEmployerOrErr() (*EMPLOYER, error) {
	if e.loadedTypes[0] {
		if e.PaymentFromEmployer == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: employer.Label}
		}
		return e.PaymentFromEmployer, nil
	}
	return nil, &NotLoadedError{edge: "payment_from_employer"}
}

// PaymentFromEmployeeOrErr returns the PaymentFromEmployee value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e PAYMENTEdges) PaymentFromEmployeeOrErr() (*EMPLOYEE, error) {
	if e.loadedTypes[1] {
		if e.PaymentFromEmployee == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: employee.Label}
		}
		return e.PaymentFromEmployee, nil
	}
	return nil, &NotLoadedError{edge: "payment_from_employee"}
}

// PaymentFromCurrencyOrErr returns the PaymentFromCurrency value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e PAYMENTEdges) PaymentFromCurrencyOrErr() (*CRYPTO_CURRENCY, error) {
	if e.loadedTypes[2] {
		if e.PaymentFromCurrency == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: crypto_currency.Label}
		}
		return e.PaymentFromCurrency, nil
	}
	return nil, &NotLoadedError{edge: "payment_from_currency"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*PAYMENT) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case payment.FieldPaymentAmount:
			values[i] = new(sql.NullFloat64)
		case payment.FieldID, payment.FieldEmployeeID, payment.FieldEmployerID, payment.FieldCryptoCurrencyID:
			values[i] = new(sql.NullInt64)
		case payment.FieldPaymentScheduled, payment.FieldPaymentExecuted:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type PAYMENT", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the PAYMENT fields.
func (pa *PAYMENT) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case payment.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			pa.ID = int(value.Int64)
		case payment.FieldEmployeeID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field employee_id", values[i])
			} else if value.Valid {
				pa.EmployeeID = int(value.Int64)
			}
		case payment.FieldEmployerID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field employer_id", values[i])
			} else if value.Valid {
				pa.EmployerID = int(value.Int64)
			}
		case payment.FieldPaymentScheduled:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field payment_scheduled", values[i])
			} else if value.Valid {
				pa.PaymentScheduled = value.Time
			}
		case payment.FieldPaymentExecuted:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field payment_executed", values[i])
			} else if value.Valid {
				pa.PaymentExecuted = value.Time
			}
		case payment.FieldPaymentAmount:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field payment_amount", values[i])
			} else if value.Valid {
				pa.PaymentAmount = value.Float64
			}
		case payment.FieldCryptoCurrencyID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field crypto_currency_id", values[i])
			} else if value.Valid {
				pa.CryptoCurrencyID = int(value.Int64)
			}
		}
	}
	return nil
}

// QueryPaymentFromEmployer queries the "payment_from_employer" edge of the PAYMENT entity.
func (pa *PAYMENT) QueryPaymentFromEmployer() *EMPLOYERQuery {
	return (&PAYMENTClient{config: pa.config}).QueryPaymentFromEmployer(pa)
}

// QueryPaymentFromEmployee queries the "payment_from_employee" edge of the PAYMENT entity.
func (pa *PAYMENT) QueryPaymentFromEmployee() *EMPLOYEEQuery {
	return (&PAYMENTClient{config: pa.config}).QueryPaymentFromEmployee(pa)
}

// QueryPaymentFromCurrency queries the "payment_from_currency" edge of the PAYMENT entity.
func (pa *PAYMENT) QueryPaymentFromCurrency() *CRYPTOCURRENCYQuery {
	return (&PAYMENTClient{config: pa.config}).QueryPaymentFromCurrency(pa)
}

// Update returns a builder for updating this PAYMENT.
// Note that you need to call PAYMENT.Unwrap() before calling this method if this PAYMENT
// was returned from a transaction, and the transaction was committed or rolled back.
func (pa *PAYMENT) Update() *PAYMENTUpdateOne {
	return (&PAYMENTClient{config: pa.config}).UpdateOne(pa)
}

// Unwrap unwraps the PAYMENT entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (pa *PAYMENT) Unwrap() *PAYMENT {
	_tx, ok := pa.config.driver.(*txDriver)
	if !ok {
		panic("ent: PAYMENT is not a transactional entity")
	}
	pa.config.driver = _tx.drv
	return pa
}

// String implements the fmt.Stringer.
func (pa *PAYMENT) String() string {
	var builder strings.Builder
	builder.WriteString("PAYMENT(")
	builder.WriteString(fmt.Sprintf("id=%v, ", pa.ID))
	builder.WriteString("employee_id=")
	builder.WriteString(fmt.Sprintf("%v", pa.EmployeeID))
	builder.WriteString(", ")
	builder.WriteString("employer_id=")
	builder.WriteString(fmt.Sprintf("%v", pa.EmployerID))
	builder.WriteString(", ")
	builder.WriteString("payment_scheduled=")
	builder.WriteString(pa.PaymentScheduled.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("payment_executed=")
	builder.WriteString(pa.PaymentExecuted.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("payment_amount=")
	builder.WriteString(fmt.Sprintf("%v", pa.PaymentAmount))
	builder.WriteString(", ")
	builder.WriteString("crypto_currency_id=")
	builder.WriteString(fmt.Sprintf("%v", pa.CryptoCurrencyID))
	builder.WriteByte(')')
	return builder.String()
}

// PAYMENTs is a parsable slice of PAYMENT.
type PAYMENTs []*PAYMENT

func (pa PAYMENTs) config(cfg config) {
	for _i := range pa {
		pa[_i].config = cfg
	}
}
